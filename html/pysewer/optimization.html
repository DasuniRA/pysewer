<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pysewer.optimization API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pysewer.optimization</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging
logger = logging.getLogger(__name__)

import math
import os
import random
from operator import itemgetter

import geopandas as gpd
import matplotlib.pyplot as plt
import networkx as nx
import numpy as np
import shapely
from shapely.geometry import LineString, MultiLineString, Point, Polygon
from shapely.ops import linemerge, nearest_points

from .helper import get_mean_slope, get_node_keys, get_upstream_nodes


def place_lifting_station(G, node):
    &#34;&#34;&#34;Places lifting station at specified node in G&#34;&#34;&#34;
    node_attrs = {node: {&#34;lifting_station&#34;: True}}
    nx.set_node_attributes(G, node_attrs)
    return G


def get_max_upstream_diameter(G, edge):
    &#34;&#34;&#34;
    Returns the maximum diameter of all upstream edges of the given edge in the directed graph G.

    Parameters
    ----------
    G : networkx.DiGraph
        The directed graph.
    edge : tuple
        The edge for which to find the maximum upstream diameter.

    Returns
    -------
    float
        The maximum diameter of all upstream edges of the given edge.
    &#34;&#34;&#34;
    diameters = []
    for u, v, data in G.in_edges(edge[0], data=True):
        diameters.append(data[&#34;diameter&#34;])
    return max(diameters)


import networkx as nx


def place_pump(G, node):
    &#34;&#34;&#34;
    Places a pump at the specified node in the graph G and sets downstream edges &#34;pressurized&#34; attribute.

    Parameters
    ----------
    G : networkx.Graph
        The graph in which the pump is to be placed.
    node : hashable
        The node at which the pump is to be placed.

    Returns
    -------
    networkx.Graph
        The graph with the pump placed at the specified node and downstream edges &#34;pressurized&#34; attribute set.
    &#34;&#34;&#34;
    if G.out_degree(node) != 1:
        print(node)
    node_attrs = {node: {&#34;pumping_station&#34;: True}}
    nx.set_node_attributes(G, node_attrs)
    downstream = next(G.neighbors(node))
    edge_attrs = {(node, downstream): {&#34;pressurized&#34;: True}}
    nx.set_edge_attributes(G, edge_attrs)
    return G


def set_diameter(G:nx.Graph, edge:tuple, diameter:float):
    &#34;&#34;&#34;
    Set the diameter of an edge in a graph.

    Parameters:
    -----------
    G : networkx.Graph
        The graph to modify.
    edge : tuple
        The edge to modify.
    diameter : float
        The diameter to set.

    Returns:
    --------
    networkx.Graph
        The modified graph.
    &#34;&#34;&#34;
    max_us = get_max_upstream_diameter(G, edge)
    if diameter &lt; max_us:
        diameter = max_us
    edge_attrs = {(edge[0], edge[1]): {&#34;diameter&#34;: diameter}}
    nx.set_edge_attributes(G, edge_attrs)
    return G


def get_downstream_junction(G:nx.Graph, node:int):
    &#34;&#34;&#34;
    Returns the next downstream junction from the specified node in G.

    Parameters
    ----------
    G : networkx.Graph
        The graph to search for the downstream junction.
    node : int
        The node to start the search from.

    Returns
    -------
    int
        The downstream junction from the specified node in G.

    Notes
    -----
    The downstream junction is defined as the next junction in the graph that has a degree greater than 2 or an out-degree of 0.
    &#34;&#34;&#34;
    junction = next(G.neighbors(node))
    while G.degree(junction) &lt;= 2 and G.out_degree(junction) &gt; 0:
        junction = next(G.neighbors(junction))
    return junction


def get_junction_front(G:nx.Graph, junctions):
    &#34;&#34;&#34;
    Returns a list of junctions or terminals which have as many entries for inflow trench depths as they have incoming edges.

    Parameters
    ----------
    G : networkx.DiGraph
        A directed graph representing the sewer network.
    junctions : list
        A list of junctions or terminals in the sewer network.

    Returns
    -------
    list
        A list of junctions or terminals which have as many entries for inflow trench depths as they have incoming edges.
    &#34;&#34;&#34;
    r = [
        n
        for n in G.nodes()
        if G.in_degree(n) == G.nodes[n][&#34;upstream_traversed&#34;] and n in junctions
    ]
    return r


def reverse_bfs(G, sink, include_private_sewer=True):
    &#34;&#34;&#34;
    Returns an iterator over edges in a sequential fashion, starting at the terminals (i.e. buildings) and returning all upstream edges of a junction before moving downstream

    Parameters
    ----------
    G : networkx.DiGraph
        The graph to traverse
    sink : str
        The node to start the traversal from
    include_private_sewer : bool, optional
        Whether to include private sewer nodes in the traversal, by default True

    Yields
    ------
    tuple
        A tuple representing an edge in the graph, in the form (source, target)
    &#34;&#34;&#34;
    if not include_private_sewer:
        # reduce graph
        buildings = get_node_keys(G, field=&#34;node_type&#34;, value=&#34;building&#34;)
        # remove buildings
        G.remove_nodes_from(buildings)
    # We start from the sink in reversed graph direction
    bfs_edges = list(nx.edge_bfs(G, sink, orientation=&#34;reverse&#34;))
    # We then flip the list and return the reversed edges to start from sources
    for edge in reversed(bfs_edges):
        yield ((edge[0], edge[1]))


def calculate_hydraulic_parameters(
    G, sinks, pressurized_diameter, diameters, roughness, include_private_sewer=True
):
    &#34;&#34;&#34;
    Calculates hydraulic parameters for a sewer network graph.

    Parameters
    ----------
    G : networkx.Graph
        The sewer network graph.
    sinks : list
        A list of sink nodes in the graph.
    pressurized_diameter : float
        The diameter of pressurized pipes in the network.
    diameters : list
        A list of available pipe diameters.
    roughness : float
        The roughness coefficient of the pipes.
    include_private_sewer : bool, optional
        Whether to include private sewer connections in the graph, by default True.

    Returns
    -------
    networkx.Graph
        The sewer network graph with updated hydraulic parameters.

    Notes
    -----
    This function places pumps/lifting stations on linear sections between road junctions.
    Three cases are possible:
    1. Terrain does not allow for gravity flow to the downstream node (this check uses the &#34;needs_pump&#34; attribute from the preprocessing
    to reduce computational load) -&gt; place pump
    2. Terrain does not require pump but lowest inflow trench depth is too low for gravitational flow -&gt; place lifting station
    3. Gravity flow is possible within given constraints
    &#34;&#34;&#34;
    min_trench_depth = 0
    nx.set_node_attributes(G, [0], name=&#34;inflow_trench_depths&#34;)
    nx.set_node_attributes(G, [0], name=&#34;inflow_diameters&#34;)
    nx.set_edge_attributes(G, False, name=&#34;pressurized&#34;)
    edge_counter = 0
    buildings = get_node_keys(G, field=&#34;node_type&#34;, value=&#34;building&#34;)
    onsite_nodes = [n for n in G.nodes() if G.degree(n) == 0 and n in buildings]
    print(len(onsite_nodes))
    node_attrs = {n: {&#34;onsite&#34;: True} for n in onsite_nodes}
    nx.set_node_attributes(G, node_attrs)
    for sink in sinks:
        if sink not in G:
            print(f&#34;Sink {sink} not in graph&#34;)
        for edge in reverse_bfs(G, sink, include_private_sewer=include_private_sewer):
            # Node Values for trench depths cant be clearly defined for pumps and lifting stations because they have seperate incoming and outcoming values
            pressurized = False
            upstream = edge[0]
            downstream = edge[1]
            max_inflow_diameters = max(G.nodes[upstream][&#34;inflow_diameters&#34;])
            max_inflow_tds = max(G.nodes[upstream][&#34;inflow_trench_depths&#34;])
            profile = G.edges[edge][&#34;profile&#34;]

            # Does the edge need a pump starting at min td?
            needs_p, out_trench_depth, td_profile = needs_pump(
                profile=profile, inflow_trench_depth=min_trench_depth
            )
            if needs_p:
                G = place_pump(G, upstream)
                pressurized = True
                edge_attrs = {
                    edge: {
                        &#34;trench_depth_profile&#34;: td_profile,
                        &#34;mean_td&#34;: np.mean(
                            [topo[1] - td[1] for td, topo in zip(td_profile, profile)]
                        ),
                    }
                }

            else:
                # check if edge needs a lifting station based on max inflow td
                needs_p, out_trench_depth, td_profile = needs_pump(
                    profile=profile, inflow_trench_depth=max_inflow_tds
                )
                if needs_p:
                    G = place_lifting_station(G, upstream)
                    # update outflow td value now with lifting station at start of edge
                    _, out_trench_depth, td_profile = needs_pump(
                        profile=profile, inflow_trench_depth=min_trench_depth
                    )
                # append downstream inflow td value
                node_attrs = {
                    downstream: {
                        &#34;inflow_trench_depths&#34;: G.nodes()[downstream][
                            &#34;inflow_trench_depths&#34;
                        ]
                        + [out_trench_depth]
                    }
                }
                nx.set_node_attributes(G, node_attrs)
                # add trenchdepth profile to edge:
                edge_attrs = {
                    edge: {
                        &#34;trench_depth_profile&#34;: td_profile,
                        &#34;mean_td&#34;: np.mean(
                            [topo[1] - td[1] for td, topo in zip(td_profile, profile)]
                        ),
                    }
                }
            # Diameter
            nx.set_edge_attributes(G, edge_attrs)

            slope = get_mean_slope(
                G, upstream, downstream, td_profile[0][1], td_profile[-1][1]
            )
            peak_flow = G.nodes[upstream][&#34;peak_flow&#34;]
            if pressurized:
                diam = pressurized_diameter
            else:
                diam = select_diameter(peak_flow, diameters, roughness, slope)
                if diam &lt; max_inflow_diameters:
                    diam = max_inflow_diameters
            # Write results to graph
            edge_attrs = {
                edge: {
                    &#34;diameter&#34;: diam,
                    &#34;peak_flow&#34;: peak_flow,
                    &#34;edge_counter&#34;: edge_counter,
                }
            }
            nx.set_edge_attributes(G, edge_attrs)
            edge_counter += 1
            node_attrs = {
                downstream: {
                    &#34;inflow_trench_depths&#34;: G.nodes[downstream][&#34;inflow_trench_depths&#34;]
                    + [out_trench_depth]
                }
            }
            nx.set_node_attributes(G, node_attrs)

            # diameter
            node_attrs = {
                downstream: {
                    &#34;inflow_diameters&#34;: G.nodes()[downstream][&#34;inflow_diameters&#34;]
                    + [diam]
                }
            }
            nx.set_node_attributes(G, node_attrs)

    return G


def estimate_peakflow(
    G, inhabitants_dwelling, daily_wastewater_person, peak_factor=2.3
):
    &#34;&#34;&#34;
    Estimate the peakflow in m³/s for a node n in Graph G.

    Parameters
    ----------
    G : networkx.Graph
        The graph to estimate peakflow for.
    inhabitants_dwelling : int
        The number of inhabitants per dwelling.
    daily_wastewater_person : float
        The daily wastewater generated per person in m³.
    peak_factor : float, optional
        The peak factor to use in the calculation, by default 2.3.

    Returns
    -------
    networkx.Graph
        The graph with updated node attributes for peak flow, average daily flow, and upstream pe.
    &#34;&#34;&#34;
    for n in G.nodes():
        upstream_buildings = get_upstream_nodes(G, n, &#34;node_type&#34;, &#34;building&#34;)
        upstream_daily = (
            len(upstream_buildings) * inhabitants_dwelling * daily_wastewater_person
        )
        upstream_pe = len(upstream_buildings) * inhabitants_dwelling
        peak_flow = ((upstream_daily / 24) * peak_factor) / 3600
        atr = {
            n: {
                &#34;peak_flow&#34;: peak_flow,
                &#34;average_daily_flow&#34;: upstream_daily,
                &#34;upstream_pe&#34;: upstream_pe,
            }
        }
        nx.set_node_attributes(G, atr)
    return G


def mannings_equation(pipe_diameter: float, roughness: float, slope: float) -&gt; float:
    &#34;&#34;&#34;
    Calculates the volume flow rate of a pipe using Manning&#39;s equation.

    Parameters
    ----------
    pipe_diameter : float
        Diameter of the pipe in meters.
    roughness : float
        Roughness coefficient of the pipe.
    slope : float
        Slope of the pipe in units of elevation drop per unit length.

    Returns
    -------
    float
        Volume flow rate of the pipe in cubic meters per second.

    Raises
    ------
    ValueError
        If the slope is greater than 0.

    Notes
    -----
    Manning&#39;s equation is used to calculate the volume flow rate of a pipe based on its diameter, roughness coefficient, and slope.
    &#34;&#34;&#34;
    # check slope for correctness:
    if slope &gt; 0:
        raise ValueError(
            &#34;Slope &gt; 0, make sure slope is in negative units in elevation drop/ unit in length&#34;
        )
    # calculating cross section for half full flow:
    A = 0.5 * math.pi * (pipe_diameter / 2) ** 2
    # wetted perimeter
    P = 0.5 * 2 * math.pi * pipe_diameter / 2
    # hydraulic radius
    Rh = A / P
    # cross sectional mean velocity
    v = (1 / roughness) * Rh ** (2 / 3) * (-1 * slope) ** 0.5
    # volume_flow
    q = A * v
    return q


def select_diameter(target_flow, diameters, roughness, slope):
    &#34;&#34;&#34;
    Returns the minimum pipe diameter.

    Parameters
    ----------
    target_flow : float
        The target flow rate in cubic meters per second.
    diameters : list
        A list of possible pipe diameters in meters.
    roughness : float
        The pipe roughness coefficient in meters.
    slope : float
        The pipe slope in meters per meter.

    Returns
    -------
    float
        The minimum pipe diameter required to achieve the target flow rate.

    Raises
    ------
    ValueError
        If the maximum diameter is insufficient to reach the target flow rate.
    &#34;&#34;&#34;
    diameters = diameters.copy()
    flow = 0
    while flow &lt;= target_flow:
        try:
            selected_diameter = diameters.pop(0)
        except:
            raise ValueError(&#34;Maximum Diameter insufficient to reach target flow&#34;)
        flow = mannings_equation(selected_diameter, roughness, slope)
    return selected_diameter


def needs_pump(profile, min_slope=-0.01, tmax=8, tmin=0.25, inflow_trench_depth=0):
    &#34;&#34;&#34;
    Traces a profile to determine if gravitational flow can be achieved within slope and trench depth constraints.

    Parameters
    ----------
    profile : list of tuples
        A list of (x, y) tuples representing the profile to be traced.
    min_slope : float, optional
        The minimum slope required for gravitational flow. Default is -0.01.
    tmax : float, optional
        The maximum trench depth allowed. Default is 8.
    tmin : float, optional
        The minimum trench depth allowed. Default is 0.25.
    inflow_trench_depth : float, optional
        The trench depth at the inflow point. If not specified, it is set to tmin.

    Returns
    -------
    tuple
        A tuple containing:
        - A boolean indicating whether a pump is needed.
        - The height difference between the outflow and the trench depth at the outflow point.
        - A list of (x, trench_depth) tuples representing the trench depth at each point along the profile.
    &#34;&#34;&#34;
    x, y = zip(*profile)
    if inflow_trench_depth == 0:
        inflow_trench_depth = tmin
    trench_depth = [0] * len(x)
    # adjust inflow trenchdepth
    trench_depth[0] = np.array(y)[0] - inflow_trench_depth
    for i in range(len(x) - 1):
        dx = x[i + 1] - x[i]
        next_min_elevation = dx * min_slope + trench_depth[i]
        ## Case 1: to achieve the min slope we would need to dig a trench deeper than tmax -&gt; needs pump
        if next_min_elevation &lt; y[i + 1] - tmax:
            return (
                True,
                0,
                [
                    (
                        0,
                        tmin,
                    ),
                    (x[-1], tmin),
                ],
            )
        ## case 2: min slope point is within Trench depth range: set trench depth to calculated height
        elif (
            next_min_elevation &lt; y[i + 1] - tmin
            and next_min_elevation &gt; y[i + 1] - tmax
        ):
            trench_depth[i + 1] = next_min_elevation
        ##case 3: min slope point is higher than min trenchdepth: set to tmin
        elif next_min_elevation &gt;= y[i + 1] - tmin:
            trench_depth[i + 1] = y[i + 1] - tmin
    return (False, y[-1] - trench_depth[-1], list(zip(x, trench_depth)))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pysewer.optimization.calculate_hydraulic_parameters"><code class="name flex">
<span>def <span class="ident">calculate_hydraulic_parameters</span></span>(<span>G, sinks, pressurized_diameter, diameters, roughness, include_private_sewer=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates hydraulic parameters for a sewer network graph.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>networkx.Graph</code></dt>
<dd>The sewer network graph.</dd>
<dt><strong><code>sinks</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of sink nodes in the graph.</dd>
<dt><strong><code>pressurized_diameter</code></strong> :&ensp;<code>float</code></dt>
<dd>The diameter of pressurized pipes in the network.</dd>
<dt><strong><code>diameters</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of available pipe diameters.</dd>
<dt><strong><code>roughness</code></strong> :&ensp;<code>float</code></dt>
<dd>The roughness coefficient of the pipes.</dd>
<dt><strong><code>include_private_sewer</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to include private sewer connections in the graph, by default True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>networkx.Graph</code></dt>
<dd>The sewer network graph with updated hydraulic parameters.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This function places pumps/lifting stations on linear sections between road junctions.
Three cases are possible:
1. Terrain does not allow for gravity flow to the downstream node (this check uses the "needs_pump" attribute from the preprocessing
to reduce computational load) -&gt; place pump
2. Terrain does not require pump but lowest inflow trench depth is too low for gravitational flow -&gt; place lifting station
3. Gravity flow is possible within given constraints</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_hydraulic_parameters(
    G, sinks, pressurized_diameter, diameters, roughness, include_private_sewer=True
):
    &#34;&#34;&#34;
    Calculates hydraulic parameters for a sewer network graph.

    Parameters
    ----------
    G : networkx.Graph
        The sewer network graph.
    sinks : list
        A list of sink nodes in the graph.
    pressurized_diameter : float
        The diameter of pressurized pipes in the network.
    diameters : list
        A list of available pipe diameters.
    roughness : float
        The roughness coefficient of the pipes.
    include_private_sewer : bool, optional
        Whether to include private sewer connections in the graph, by default True.

    Returns
    -------
    networkx.Graph
        The sewer network graph with updated hydraulic parameters.

    Notes
    -----
    This function places pumps/lifting stations on linear sections between road junctions.
    Three cases are possible:
    1. Terrain does not allow for gravity flow to the downstream node (this check uses the &#34;needs_pump&#34; attribute from the preprocessing
    to reduce computational load) -&gt; place pump
    2. Terrain does not require pump but lowest inflow trench depth is too low for gravitational flow -&gt; place lifting station
    3. Gravity flow is possible within given constraints
    &#34;&#34;&#34;
    min_trench_depth = 0
    nx.set_node_attributes(G, [0], name=&#34;inflow_trench_depths&#34;)
    nx.set_node_attributes(G, [0], name=&#34;inflow_diameters&#34;)
    nx.set_edge_attributes(G, False, name=&#34;pressurized&#34;)
    edge_counter = 0
    buildings = get_node_keys(G, field=&#34;node_type&#34;, value=&#34;building&#34;)
    onsite_nodes = [n for n in G.nodes() if G.degree(n) == 0 and n in buildings]
    print(len(onsite_nodes))
    node_attrs = {n: {&#34;onsite&#34;: True} for n in onsite_nodes}
    nx.set_node_attributes(G, node_attrs)
    for sink in sinks:
        if sink not in G:
            print(f&#34;Sink {sink} not in graph&#34;)
        for edge in reverse_bfs(G, sink, include_private_sewer=include_private_sewer):
            # Node Values for trench depths cant be clearly defined for pumps and lifting stations because they have seperate incoming and outcoming values
            pressurized = False
            upstream = edge[0]
            downstream = edge[1]
            max_inflow_diameters = max(G.nodes[upstream][&#34;inflow_diameters&#34;])
            max_inflow_tds = max(G.nodes[upstream][&#34;inflow_trench_depths&#34;])
            profile = G.edges[edge][&#34;profile&#34;]

            # Does the edge need a pump starting at min td?
            needs_p, out_trench_depth, td_profile = needs_pump(
                profile=profile, inflow_trench_depth=min_trench_depth
            )
            if needs_p:
                G = place_pump(G, upstream)
                pressurized = True
                edge_attrs = {
                    edge: {
                        &#34;trench_depth_profile&#34;: td_profile,
                        &#34;mean_td&#34;: np.mean(
                            [topo[1] - td[1] for td, topo in zip(td_profile, profile)]
                        ),
                    }
                }

            else:
                # check if edge needs a lifting station based on max inflow td
                needs_p, out_trench_depth, td_profile = needs_pump(
                    profile=profile, inflow_trench_depth=max_inflow_tds
                )
                if needs_p:
                    G = place_lifting_station(G, upstream)
                    # update outflow td value now with lifting station at start of edge
                    _, out_trench_depth, td_profile = needs_pump(
                        profile=profile, inflow_trench_depth=min_trench_depth
                    )
                # append downstream inflow td value
                node_attrs = {
                    downstream: {
                        &#34;inflow_trench_depths&#34;: G.nodes()[downstream][
                            &#34;inflow_trench_depths&#34;
                        ]
                        + [out_trench_depth]
                    }
                }
                nx.set_node_attributes(G, node_attrs)
                # add trenchdepth profile to edge:
                edge_attrs = {
                    edge: {
                        &#34;trench_depth_profile&#34;: td_profile,
                        &#34;mean_td&#34;: np.mean(
                            [topo[1] - td[1] for td, topo in zip(td_profile, profile)]
                        ),
                    }
                }
            # Diameter
            nx.set_edge_attributes(G, edge_attrs)

            slope = get_mean_slope(
                G, upstream, downstream, td_profile[0][1], td_profile[-1][1]
            )
            peak_flow = G.nodes[upstream][&#34;peak_flow&#34;]
            if pressurized:
                diam = pressurized_diameter
            else:
                diam = select_diameter(peak_flow, diameters, roughness, slope)
                if diam &lt; max_inflow_diameters:
                    diam = max_inflow_diameters
            # Write results to graph
            edge_attrs = {
                edge: {
                    &#34;diameter&#34;: diam,
                    &#34;peak_flow&#34;: peak_flow,
                    &#34;edge_counter&#34;: edge_counter,
                }
            }
            nx.set_edge_attributes(G, edge_attrs)
            edge_counter += 1
            node_attrs = {
                downstream: {
                    &#34;inflow_trench_depths&#34;: G.nodes[downstream][&#34;inflow_trench_depths&#34;]
                    + [out_trench_depth]
                }
            }
            nx.set_node_attributes(G, node_attrs)

            # diameter
            node_attrs = {
                downstream: {
                    &#34;inflow_diameters&#34;: G.nodes()[downstream][&#34;inflow_diameters&#34;]
                    + [diam]
                }
            }
            nx.set_node_attributes(G, node_attrs)

    return G</code></pre>
</details>
</dd>
<dt id="pysewer.optimization.estimate_peakflow"><code class="name flex">
<span>def <span class="ident">estimate_peakflow</span></span>(<span>G, inhabitants_dwelling, daily_wastewater_person, peak_factor=2.3)</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate the peakflow in m³/s for a node n in Graph G.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>networkx.Graph</code></dt>
<dd>The graph to estimate peakflow for.</dd>
<dt><strong><code>inhabitants_dwelling</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of inhabitants per dwelling.</dd>
<dt><strong><code>daily_wastewater_person</code></strong> :&ensp;<code>float</code></dt>
<dd>The daily wastewater generated per person in m³.</dd>
<dt><strong><code>peak_factor</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The peak factor to use in the calculation, by default 2.3.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>networkx.Graph</code></dt>
<dd>The graph with updated node attributes for peak flow, average daily flow, and upstream pe.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_peakflow(
    G, inhabitants_dwelling, daily_wastewater_person, peak_factor=2.3
):
    &#34;&#34;&#34;
    Estimate the peakflow in m³/s for a node n in Graph G.

    Parameters
    ----------
    G : networkx.Graph
        The graph to estimate peakflow for.
    inhabitants_dwelling : int
        The number of inhabitants per dwelling.
    daily_wastewater_person : float
        The daily wastewater generated per person in m³.
    peak_factor : float, optional
        The peak factor to use in the calculation, by default 2.3.

    Returns
    -------
    networkx.Graph
        The graph with updated node attributes for peak flow, average daily flow, and upstream pe.
    &#34;&#34;&#34;
    for n in G.nodes():
        upstream_buildings = get_upstream_nodes(G, n, &#34;node_type&#34;, &#34;building&#34;)
        upstream_daily = (
            len(upstream_buildings) * inhabitants_dwelling * daily_wastewater_person
        )
        upstream_pe = len(upstream_buildings) * inhabitants_dwelling
        peak_flow = ((upstream_daily / 24) * peak_factor) / 3600
        atr = {
            n: {
                &#34;peak_flow&#34;: peak_flow,
                &#34;average_daily_flow&#34;: upstream_daily,
                &#34;upstream_pe&#34;: upstream_pe,
            }
        }
        nx.set_node_attributes(G, atr)
    return G</code></pre>
</details>
</dd>
<dt id="pysewer.optimization.get_downstream_junction"><code class="name flex">
<span>def <span class="ident">get_downstream_junction</span></span>(<span>G: networkx.classes.graph.Graph, node: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the next downstream junction from the specified node in G.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>networkx.Graph</code></dt>
<dd>The graph to search for the downstream junction.</dd>
<dt><strong><code>node</code></strong> :&ensp;<code>int</code></dt>
<dd>The node to start the search from.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The downstream junction from the specified node in G.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The downstream junction is defined as the next junction in the graph that has a degree greater than 2 or an out-degree of 0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_downstream_junction(G:nx.Graph, node:int):
    &#34;&#34;&#34;
    Returns the next downstream junction from the specified node in G.

    Parameters
    ----------
    G : networkx.Graph
        The graph to search for the downstream junction.
    node : int
        The node to start the search from.

    Returns
    -------
    int
        The downstream junction from the specified node in G.

    Notes
    -----
    The downstream junction is defined as the next junction in the graph that has a degree greater than 2 or an out-degree of 0.
    &#34;&#34;&#34;
    junction = next(G.neighbors(node))
    while G.degree(junction) &lt;= 2 and G.out_degree(junction) &gt; 0:
        junction = next(G.neighbors(junction))
    return junction</code></pre>
</details>
</dd>
<dt id="pysewer.optimization.get_junction_front"><code class="name flex">
<span>def <span class="ident">get_junction_front</span></span>(<span>G: networkx.classes.graph.Graph, junctions)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of junctions or terminals which have as many entries for inflow trench depths as they have incoming edges.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>networkx.DiGraph</code></dt>
<dd>A directed graph representing the sewer network.</dd>
<dt><strong><code>junctions</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of junctions or terminals in the sewer network.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of junctions or terminals which have as many entries for inflow trench depths as they have incoming edges.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_junction_front(G:nx.Graph, junctions):
    &#34;&#34;&#34;
    Returns a list of junctions or terminals which have as many entries for inflow trench depths as they have incoming edges.

    Parameters
    ----------
    G : networkx.DiGraph
        A directed graph representing the sewer network.
    junctions : list
        A list of junctions or terminals in the sewer network.

    Returns
    -------
    list
        A list of junctions or terminals which have as many entries for inflow trench depths as they have incoming edges.
    &#34;&#34;&#34;
    r = [
        n
        for n in G.nodes()
        if G.in_degree(n) == G.nodes[n][&#34;upstream_traversed&#34;] and n in junctions
    ]
    return r</code></pre>
</details>
</dd>
<dt id="pysewer.optimization.get_max_upstream_diameter"><code class="name flex">
<span>def <span class="ident">get_max_upstream_diameter</span></span>(<span>G, edge)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the maximum diameter of all upstream edges of the given edge in the directed graph G.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>networkx.DiGraph</code></dt>
<dd>The directed graph.</dd>
<dt><strong><code>edge</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The edge for which to find the maximum upstream diameter.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The maximum diameter of all upstream edges of the given edge.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_max_upstream_diameter(G, edge):
    &#34;&#34;&#34;
    Returns the maximum diameter of all upstream edges of the given edge in the directed graph G.

    Parameters
    ----------
    G : networkx.DiGraph
        The directed graph.
    edge : tuple
        The edge for which to find the maximum upstream diameter.

    Returns
    -------
    float
        The maximum diameter of all upstream edges of the given edge.
    &#34;&#34;&#34;
    diameters = []
    for u, v, data in G.in_edges(edge[0], data=True):
        diameters.append(data[&#34;diameter&#34;])
    return max(diameters)</code></pre>
</details>
</dd>
<dt id="pysewer.optimization.mannings_equation"><code class="name flex">
<span>def <span class="ident">mannings_equation</span></span>(<span>pipe_diameter: float, roughness: float, slope: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the volume flow rate of a pipe using Manning's equation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pipe_diameter</code></strong> :&ensp;<code>float</code></dt>
<dd>Diameter of the pipe in meters.</dd>
<dt><strong><code>roughness</code></strong> :&ensp;<code>float</code></dt>
<dd>Roughness coefficient of the pipe.</dd>
<dt><strong><code>slope</code></strong> :&ensp;<code>float</code></dt>
<dd>Slope of the pipe in units of elevation drop per unit length.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Volume flow rate of the pipe in cubic meters per second.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the slope is greater than 0.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Manning's equation is used to calculate the volume flow rate of a pipe based on its diameter, roughness coefficient, and slope.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mannings_equation(pipe_diameter: float, roughness: float, slope: float) -&gt; float:
    &#34;&#34;&#34;
    Calculates the volume flow rate of a pipe using Manning&#39;s equation.

    Parameters
    ----------
    pipe_diameter : float
        Diameter of the pipe in meters.
    roughness : float
        Roughness coefficient of the pipe.
    slope : float
        Slope of the pipe in units of elevation drop per unit length.

    Returns
    -------
    float
        Volume flow rate of the pipe in cubic meters per second.

    Raises
    ------
    ValueError
        If the slope is greater than 0.

    Notes
    -----
    Manning&#39;s equation is used to calculate the volume flow rate of a pipe based on its diameter, roughness coefficient, and slope.
    &#34;&#34;&#34;
    # check slope for correctness:
    if slope &gt; 0:
        raise ValueError(
            &#34;Slope &gt; 0, make sure slope is in negative units in elevation drop/ unit in length&#34;
        )
    # calculating cross section for half full flow:
    A = 0.5 * math.pi * (pipe_diameter / 2) ** 2
    # wetted perimeter
    P = 0.5 * 2 * math.pi * pipe_diameter / 2
    # hydraulic radius
    Rh = A / P
    # cross sectional mean velocity
    v = (1 / roughness) * Rh ** (2 / 3) * (-1 * slope) ** 0.5
    # volume_flow
    q = A * v
    return q</code></pre>
</details>
</dd>
<dt id="pysewer.optimization.needs_pump"><code class="name flex">
<span>def <span class="ident">needs_pump</span></span>(<span>profile, min_slope=-0.01, tmax=8, tmin=0.25, inflow_trench_depth=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Traces a profile to determine if gravitational flow can be achieved within slope and trench depth constraints.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>profile</code></strong> :&ensp;<code>list</code> of <code>tuples</code></dt>
<dd>A list of (x, y) tuples representing the profile to be traced.</dd>
<dt><strong><code>min_slope</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The minimum slope required for gravitational flow. Default is -0.01.</dd>
<dt><strong><code>tmax</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The maximum trench depth allowed. Default is 8.</dd>
<dt><strong><code>tmin</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The minimum trench depth allowed. Default is 0.25.</dd>
<dt><strong><code>inflow_trench_depth</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The trench depth at the inflow point. If not specified, it is set to tmin.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>A tuple containing:
- A boolean indicating whether a pump is needed.
- The height difference between the outflow and the trench depth at the outflow point.
- A list of (x, trench_depth) tuples representing the trench depth at each point along the profile.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def needs_pump(profile, min_slope=-0.01, tmax=8, tmin=0.25, inflow_trench_depth=0):
    &#34;&#34;&#34;
    Traces a profile to determine if gravitational flow can be achieved within slope and trench depth constraints.

    Parameters
    ----------
    profile : list of tuples
        A list of (x, y) tuples representing the profile to be traced.
    min_slope : float, optional
        The minimum slope required for gravitational flow. Default is -0.01.
    tmax : float, optional
        The maximum trench depth allowed. Default is 8.
    tmin : float, optional
        The minimum trench depth allowed. Default is 0.25.
    inflow_trench_depth : float, optional
        The trench depth at the inflow point. If not specified, it is set to tmin.

    Returns
    -------
    tuple
        A tuple containing:
        - A boolean indicating whether a pump is needed.
        - The height difference between the outflow and the trench depth at the outflow point.
        - A list of (x, trench_depth) tuples representing the trench depth at each point along the profile.
    &#34;&#34;&#34;
    x, y = zip(*profile)
    if inflow_trench_depth == 0:
        inflow_trench_depth = tmin
    trench_depth = [0] * len(x)
    # adjust inflow trenchdepth
    trench_depth[0] = np.array(y)[0] - inflow_trench_depth
    for i in range(len(x) - 1):
        dx = x[i + 1] - x[i]
        next_min_elevation = dx * min_slope + trench_depth[i]
        ## Case 1: to achieve the min slope we would need to dig a trench deeper than tmax -&gt; needs pump
        if next_min_elevation &lt; y[i + 1] - tmax:
            return (
                True,
                0,
                [
                    (
                        0,
                        tmin,
                    ),
                    (x[-1], tmin),
                ],
            )
        ## case 2: min slope point is within Trench depth range: set trench depth to calculated height
        elif (
            next_min_elevation &lt; y[i + 1] - tmin
            and next_min_elevation &gt; y[i + 1] - tmax
        ):
            trench_depth[i + 1] = next_min_elevation
        ##case 3: min slope point is higher than min trenchdepth: set to tmin
        elif next_min_elevation &gt;= y[i + 1] - tmin:
            trench_depth[i + 1] = y[i + 1] - tmin
    return (False, y[-1] - trench_depth[-1], list(zip(x, trench_depth)))</code></pre>
</details>
</dd>
<dt id="pysewer.optimization.place_lifting_station"><code class="name flex">
<span>def <span class="ident">place_lifting_station</span></span>(<span>G, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Places lifting station at specified node in G</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def place_lifting_station(G, node):
    &#34;&#34;&#34;Places lifting station at specified node in G&#34;&#34;&#34;
    node_attrs = {node: {&#34;lifting_station&#34;: True}}
    nx.set_node_attributes(G, node_attrs)
    return G</code></pre>
</details>
</dd>
<dt id="pysewer.optimization.place_pump"><code class="name flex">
<span>def <span class="ident">place_pump</span></span>(<span>G, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Places a pump at the specified node in the graph G and sets downstream edges "pressurized" attribute.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>networkx.Graph</code></dt>
<dd>The graph in which the pump is to be placed.</dd>
<dt><strong><code>node</code></strong> :&ensp;<code>hashable</code></dt>
<dd>The node at which the pump is to be placed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>networkx.Graph</code></dt>
<dd>The graph with the pump placed at the specified node and downstream edges "pressurized" attribute set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def place_pump(G, node):
    &#34;&#34;&#34;
    Places a pump at the specified node in the graph G and sets downstream edges &#34;pressurized&#34; attribute.

    Parameters
    ----------
    G : networkx.Graph
        The graph in which the pump is to be placed.
    node : hashable
        The node at which the pump is to be placed.

    Returns
    -------
    networkx.Graph
        The graph with the pump placed at the specified node and downstream edges &#34;pressurized&#34; attribute set.
    &#34;&#34;&#34;
    if G.out_degree(node) != 1:
        print(node)
    node_attrs = {node: {&#34;pumping_station&#34;: True}}
    nx.set_node_attributes(G, node_attrs)
    downstream = next(G.neighbors(node))
    edge_attrs = {(node, downstream): {&#34;pressurized&#34;: True}}
    nx.set_edge_attributes(G, edge_attrs)
    return G</code></pre>
</details>
</dd>
<dt id="pysewer.optimization.reverse_bfs"><code class="name flex">
<span>def <span class="ident">reverse_bfs</span></span>(<span>G, sink, include_private_sewer=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an iterator over edges in a sequential fashion, starting at the terminals (i.e. buildings) and returning all upstream edges of a junction before moving downstream</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>networkx.DiGraph</code></dt>
<dd>The graph to traverse</dd>
<dt><strong><code>sink</code></strong> :&ensp;<code>str</code></dt>
<dd>The node to start the traversal from</dd>
<dt><strong><code>include_private_sewer</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to include private sewer nodes in the traversal, by default True</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>A tuple representing an edge in the graph, in the form (source, target)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reverse_bfs(G, sink, include_private_sewer=True):
    &#34;&#34;&#34;
    Returns an iterator over edges in a sequential fashion, starting at the terminals (i.e. buildings) and returning all upstream edges of a junction before moving downstream

    Parameters
    ----------
    G : networkx.DiGraph
        The graph to traverse
    sink : str
        The node to start the traversal from
    include_private_sewer : bool, optional
        Whether to include private sewer nodes in the traversal, by default True

    Yields
    ------
    tuple
        A tuple representing an edge in the graph, in the form (source, target)
    &#34;&#34;&#34;
    if not include_private_sewer:
        # reduce graph
        buildings = get_node_keys(G, field=&#34;node_type&#34;, value=&#34;building&#34;)
        # remove buildings
        G.remove_nodes_from(buildings)
    # We start from the sink in reversed graph direction
    bfs_edges = list(nx.edge_bfs(G, sink, orientation=&#34;reverse&#34;))
    # We then flip the list and return the reversed edges to start from sources
    for edge in reversed(bfs_edges):
        yield ((edge[0], edge[1]))</code></pre>
</details>
</dd>
<dt id="pysewer.optimization.select_diameter"><code class="name flex">
<span>def <span class="ident">select_diameter</span></span>(<span>target_flow, diameters, roughness, slope)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the minimum pipe diameter.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>target_flow</code></strong> :&ensp;<code>float</code></dt>
<dd>The target flow rate in cubic meters per second.</dd>
<dt><strong><code>diameters</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of possible pipe diameters in meters.</dd>
<dt><strong><code>roughness</code></strong> :&ensp;<code>float</code></dt>
<dd>The pipe roughness coefficient in meters.</dd>
<dt><strong><code>slope</code></strong> :&ensp;<code>float</code></dt>
<dd>The pipe slope in meters per meter.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The minimum pipe diameter required to achieve the target flow rate.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the maximum diameter is insufficient to reach the target flow rate.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_diameter(target_flow, diameters, roughness, slope):
    &#34;&#34;&#34;
    Returns the minimum pipe diameter.

    Parameters
    ----------
    target_flow : float
        The target flow rate in cubic meters per second.
    diameters : list
        A list of possible pipe diameters in meters.
    roughness : float
        The pipe roughness coefficient in meters.
    slope : float
        The pipe slope in meters per meter.

    Returns
    -------
    float
        The minimum pipe diameter required to achieve the target flow rate.

    Raises
    ------
    ValueError
        If the maximum diameter is insufficient to reach the target flow rate.
    &#34;&#34;&#34;
    diameters = diameters.copy()
    flow = 0
    while flow &lt;= target_flow:
        try:
            selected_diameter = diameters.pop(0)
        except:
            raise ValueError(&#34;Maximum Diameter insufficient to reach target flow&#34;)
        flow = mannings_equation(selected_diameter, roughness, slope)
    return selected_diameter</code></pre>
</details>
</dd>
<dt id="pysewer.optimization.set_diameter"><code class="name flex">
<span>def <span class="ident">set_diameter</span></span>(<span>G: networkx.classes.graph.Graph, edge: tuple, diameter: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the diameter of an edge in a graph.</p>
<h2 id="parameters">Parameters:</h2>
<p>G : networkx.Graph
The graph to modify.
edge : tuple
The edge to modify.
diameter : float
The diameter to set.</p>
<h2 id="returns">Returns:</h2>
<p>networkx.Graph
The modified graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_diameter(G:nx.Graph, edge:tuple, diameter:float):
    &#34;&#34;&#34;
    Set the diameter of an edge in a graph.

    Parameters:
    -----------
    G : networkx.Graph
        The graph to modify.
    edge : tuple
        The edge to modify.
    diameter : float
        The diameter to set.

    Returns:
    --------
    networkx.Graph
        The modified graph.
    &#34;&#34;&#34;
    max_us = get_max_upstream_diameter(G, edge)
    if diameter &lt; max_us:
        diameter = max_us
    edge_attrs = {(edge[0], edge[1]): {&#34;diameter&#34;: diameter}}
    nx.set_edge_attributes(G, edge_attrs)
    return G</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pysewer" href="index.html">pysewer</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pysewer.optimization.calculate_hydraulic_parameters" href="#pysewer.optimization.calculate_hydraulic_parameters">calculate_hydraulic_parameters</a></code></li>
<li><code><a title="pysewer.optimization.estimate_peakflow" href="#pysewer.optimization.estimate_peakflow">estimate_peakflow</a></code></li>
<li><code><a title="pysewer.optimization.get_downstream_junction" href="#pysewer.optimization.get_downstream_junction">get_downstream_junction</a></code></li>
<li><code><a title="pysewer.optimization.get_junction_front" href="#pysewer.optimization.get_junction_front">get_junction_front</a></code></li>
<li><code><a title="pysewer.optimization.get_max_upstream_diameter" href="#pysewer.optimization.get_max_upstream_diameter">get_max_upstream_diameter</a></code></li>
<li><code><a title="pysewer.optimization.mannings_equation" href="#pysewer.optimization.mannings_equation">mannings_equation</a></code></li>
<li><code><a title="pysewer.optimization.needs_pump" href="#pysewer.optimization.needs_pump">needs_pump</a></code></li>
<li><code><a title="pysewer.optimization.place_lifting_station" href="#pysewer.optimization.place_lifting_station">place_lifting_station</a></code></li>
<li><code><a title="pysewer.optimization.place_pump" href="#pysewer.optimization.place_pump">place_pump</a></code></li>
<li><code><a title="pysewer.optimization.reverse_bfs" href="#pysewer.optimization.reverse_bfs">reverse_bfs</a></code></li>
<li><code><a title="pysewer.optimization.select_diameter" href="#pysewer.optimization.select_diameter">select_diameter</a></code></li>
<li><code><a title="pysewer.optimization.set_diameter" href="#pysewer.optimization.set_diameter">set_diameter</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>