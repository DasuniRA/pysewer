<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pysewer.helper API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pysewer.helper</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import itertools
from operator import itemgetter
from typing import Any, List

import geopandas as gpd
import networkx as nx
import numpy as np
import pandas as pd
import shapely
from scipy.spatial import cKDTree, distance
from shapely.geometry import *
from shapely.geometry import LineString, Point


def get_upstream_nodes(G: nx.DiGraph, start_node, field: str, value: str) -&gt; List:
    &#34;&#34;&#34;
    Returns a list of all upstream nodes in a directed graph `G` that have a node attribute `field` with value `value`,
    starting from `start_node` and traversing the graph in reverse order using a breadth-first search algorithm.

    Parameters
    ----------
    G : networkx.DiGraph
        The directed graph to traverse.
    start_node : hashable
        The node to start the traversal from.
    field : str
        The name of the node attribute to filter by.
    value : Any
        The value of the node attribute to filter by.

    Returns
    -------
    List
        A list of all upstream nodes in `G` that have a node attribute `field` with value `value`.
    &#34;&#34;&#34;
    return [
        n
        for n in nx.traversal.bfs_tree(G, start_node, reverse=True)
        if G.nodes(data=field, default=None)[n] == value
    ]


def get_path_distance(detailed_path: List[tuple]) -&gt; float:
    &#34;&#34;&#34;
    Calculates the total distance of a path given a list of detailed path coordinates.

    Parameters
    ----------
    detailed_path : List[tuple]
        A list of tuples representing the detailed path coordinates.

    Returns
    -------
    float
        The total distance of the path.

    Examples
    --------
    &gt;&gt;&gt; get_path_distance([(0, 0), (3, 4), (7, 1)])
    9.848857801796104
    &#34;&#34;&#34;
    edgesinpath = zip(detailed_path[0:], detailed_path[1:])
    path_dist = 0
    for e in edgesinpath:
        path_dist += distance.euclidean(e[0], e[1])
    return path_dist


def get_closest_edge(G: nx.Graph, point: shapely.geometry.Point) -&gt; tuple:
    &#34;&#34;&#34;
    Returns the closest edge to a given point in a networkx graph.

    Parameters:
    -----------
    G : networkx.Graph
        The graph to search for the closest edge.
    point : shapely.geometry.Point
        The point to search for the closest edge.

    Returns:
    --------
    closest_edge : tuple
        A tuple representing the closest edge to the given point.
    &#34;&#34;&#34;
    edge_gdf = get_edge_gdf(G)
    edge_gdf[&#34;closest_edge&#34;] = edge_gdf.geometry.tolist()
    cc = ckdnearest(
        gpd.GeoDataFrame(geometry=[point]), edge_gdf, [&#34;closest_edge&#34;]
    ).iloc[0, 1]
    # Validate the returned type
    if not isinstance(cc, tuple):
        raise ValueError(
            &#34;Expected a tuple representing an edge but got a different type.&#34;
        )

    return cc


def get_closest_edge_multiple(G: nx.Graph, list_of_points: list) -&gt; list:
    &#34;&#34;&#34;
    Returns a list of the closest edges in a networkx graph to a list of points.

    Parameters
    ----------
    G : networkx.Graph
        A networkx graph object.
    list_of_points : list
        A list of shapely Point objects.

    Returns
    -------
    list
        A list of shapely LineString objects representing the closest edges to the input points.
    &#34;&#34;&#34;
    edge_gdf = get_edge_gdf(G)
    edge_gdf[&#34;closest_edge&#34;] = edge_gdf.geometry.tolist()
    cc = ckdnearest(
        gpd.GeoDataFrame(geometry=list_of_points), edge_gdf, [&#34;closest_edge&#34;]
    )[&#34;closest_edge&#34;].to_list()
    return cc


def get_edge_gdf(
    G: nx.Graph, field: str = None, value: any = None, detailed: bool = False
) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Returns a GeoDataFrame of edges in a networkx graph that match a given field and value.

    Parameters
    ----------
    G : networkx.Graph
        The graph to extract edges from.
    field : str, optional
        The edge attribute to filter on.
    value : any, optional
        The value to filter the edge attribute on.
    detailed : bool, optional
        If True, returns a detailed GeoDataFrame with all edge attributes. If False, returns a simplified GeoDataFrame with only the edge geometry.

    Returns
    -------
    gpd.GeoDataFrame
        A GeoDataFrame of edges that match the given field and value.
    &#34;&#34;&#34;
    edges = get_edge_keys(G, field=field, value=value)
    # If no matching edges are found, return an empty GeoDataFrame
    if not edges:
        return gpd.GeoDataFrame()

    data = [G[edge[0]][edge[1]] for edge in edges]

    if detailed:
        return gpd.GeoDataFrame(data)
    else:
        return gpd.GeoDataFrame(geometry=[LineString(e) for e in edges])


def get_node_gdf(G: nx.Graph, field=None, value=None) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Returns a GeoDataFrame of nodes in the graph that match the specified field and value.

    Parameters
    ----------
    G : nx.Graph
        The input graph.
    field : str, optional
        The node attribute to filter on.
    value : str, optional
        The value to filter on.

    Returns
    -------
    gdf : gpd.GeoDataFrame
        A GeoDataFrame of nodes that match the specified field and value.

    Raises
    ------
    ValueError
        If no geometry column is found in the GeoDataFrame.

    Notes
    -----
    This function filters the nodes in the input graph based on the specified field and value, and returns a GeoDataFrame
    containing the filtered nodes and their attributes. The GeoDataFrame is created using the coordinates of the filtered
    nodes and their attributes.

    &#34;&#34;&#34;
    coord_tuples = get_node_keys(G, field=field, value=value)
    try:
        x, y = zip(*coord_tuples)
        data = [G.nodes(data=True)[n] for n in coord_tuples]
        gdf = gpd.GeoDataFrame(data, geometry=gpd.points_from_xy(x, y))
        if &#34;geometry&#34; not in gdf.columns:
            raise ValueError(&#34;No geometry column found in the GeoDataFrame.&#34;)

        return gdf.set_geometry(&#34;geometry&#34;)

    except:
        return gpd.GeoDataFrame()


def get_node_keys(G: nx.Graph, field: str = None, value: str = None):
    &#34;&#34;&#34;
    Returns a list of keys for nodes in the graph `G` that have a specified `field` with a specified `value`.

    Parameters:
    -----------
    G : networkx.Graph
        The graph to search for nodes.
    field : str, optional
        The field to search for in the node data dictionary. If None, all nodes are returned.
    value : str
        The value to search for in the specified `field`. If None, all nodes with the specified `field` are returned.

    Returns:
    --------
    list
        A list of keys for nodes in the graph `G` that have a specified `field` with a specified `value`.
    &#34;&#34;&#34;
    return [x for x, y in G.nodes(data=field, default=None) if y == value]


def get_edge_keys(G, field=None, value=None):
    &#34;&#34;&#34;
    Returns a list of edge keys (tuples of nodes) for the given graph `G` that have an edge attribute `field` with value `value`.

    Parameters:
    -----------
    G : networkx.Graph
        The graph to search for edges.
    field : str, optional
        The name of the edge attribute to filter on.
    value : any, optional
        The value of the edge attribute to filter on.

    Returns:
    --------
    list of tuples
        A list of edge keys (tuples of nodes) that have an edge attribute `field` with value `value`.
    &#34;&#34;&#34;
    return [(u, v) for u, v, e in G.edges(data=field, default=None) if e == value]


def get_path_gdf(G, upstream, downstream):
    &#34;&#34;&#34;
    Returns a GeoDataFrame containing the geometry of the shortest path between two nodes in a graph.

    Parameters:
    -----------
    G : networkx.Graph
        The graph to find the shortest path in.
    upstream : int
        The starting node of the path.
    downstream : int
        The ending node of the path.

    Returns:
    --------
    gpd.GeoDataFrame
        A GeoDataFrame containing the geometry of the shortest path between the upstream and downstream nodes.
    &#34;&#34;&#34;
    path = nx.dijkstra_path(G, upstream, downstream)
    edges = list(zip(path[0:], path[1:]))
    return gpd.GeoDataFrame(geometry=[G[e[0]][e[1]][&#34;geometry&#34;] for e in edges])


def get_mean_slope(
    G: nx.MultiDiGraph, upstream: int, downstream: int, us_td: float, ds_td: float
) -&gt; float:
    &#34;&#34;&#34;
    Calculates the mean slope of a path between two nodes in a graph.

    Parameters:
    -----------
    G : networkx.MultiDiGraph
        A directed graph object.
    upstream : int
        The upstream node ID.
    downstream : int
        The downstream node ID.
    us_td : float
        The upstream node topographic elevation.
    ds_td : float
        The downstream node topographic elevation.

    Returns:
    --------
    float
        The mean slope of the path between the upstream and downstream nodes.
    &#34;&#34;&#34;
    gdf = get_path_gdf(G, upstream, downstream)
    length = gdf[&#34;geometry&#34;].length.sum()
    return (ds_td - us_td) / length


def ckdnearest(
    gdfA: gpd.GeoDataFrame, gdfB: gpd.GeoDataFrame, gdfB_cols=[&#34;closest_edge&#34;]
) -&gt; gpd.GeoDataFrame:
    # resetting the index of gdfA and gdfB here.
    gdfA = gdfA.reset_index(drop=True)
    gdfB = gdfB.reset_index(drop=True)
    A = np.concatenate([np.array(geom.coords) for geom in gdfA.geometry.to_list()])
    B = [np.array(geom.coords) for geom in gdfB.geometry.to_list()]
    B_ix = tuple(
        itertools.chain.from_iterable(
            [itertools.repeat(i, x) for i, x in enumerate(list(map(len, B)))]
        )
    )
    B = np.concatenate(B)
    ckd_tree = cKDTree(B)
    dist, idx = ckd_tree.query(A, k=1)
    idx = itemgetter(*idx)(B_ix)
    gdf = pd.concat(
        [
            gdfA,
            gdfB.loc[idx, gdfB_cols].reset_index(drop=True),
            pd.Series(dist, name=&#34;dist&#34;),
        ],
        axis=1,
    )
    return gdf


def remove_third_dimension(geom):
    if geom.is_empty:
        return geom

    if isinstance(geom, Polygon):
        exterior = geom.exterior
        new_exterior = remove_third_dimension(exterior)

        interiors = geom.interiors
        new_interiors = []
        for int in interiors:
            new_interiors.append(remove_third_dimension(int))

        return Polygon(new_exterior, new_interiors)

    elif isinstance(geom, LinearRing):
        return LinearRing([xy[0:2] for xy in list(geom.coords)])

    elif isinstance(geom, LineString):
        return LineString([xy[0:2] for xy in list(geom.coords)])

    elif isinstance(geom, Point):
        return Point([xy[0:2] for xy in list(geom.coords)])

    elif isinstance(geom, MultiPoint):
        points = list(geom.geoms)
        new_points = []
        for point in points:
            new_points.append(remove_third_dimension(point))

        return MultiPoint(new_points)

    elif isinstance(geom, MultiLineString):
        lines = list(geom.geoms)
        new_lines = []
        for line in lines:
            new_lines.append(remove_third_dimension(line))

        return MultiLineString(new_lines)

    elif isinstance(geom, MultiPolygon):
        pols = list(geom.geoms)

        new_pols = []
        for pol in pols:
            new_pols.append(remove_third_dimension(pol))

        return MultiPolygon(new_pols)

    elif isinstance(geom, GeometryCollection):
        geoms = list(geom.geoms)

        new_geoms = []
        for geom in geoms:
            new_geoms.append(remove_third_dimension(geom))

        return GeometryCollection(new_geoms)

    else:
        raise RuntimeError(
            &#34;Currently this type of geometry is not supported: {}&#34;.format(type(geom))
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pysewer.helper.ckdnearest"><code class="name flex">
<span>def <span class="ident">ckdnearest</span></span>(<span>gdfA: geopandas.geodataframe.GeoDataFrame, gdfB: geopandas.geodataframe.GeoDataFrame, gdfB_cols=['closest_edge']) ‑> geopandas.geodataframe.GeoDataFrame</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ckdnearest(
    gdfA: gpd.GeoDataFrame, gdfB: gpd.GeoDataFrame, gdfB_cols=[&#34;closest_edge&#34;]
) -&gt; gpd.GeoDataFrame:
    # resetting the index of gdfA and gdfB here.
    gdfA = gdfA.reset_index(drop=True)
    gdfB = gdfB.reset_index(drop=True)
    A = np.concatenate([np.array(geom.coords) for geom in gdfA.geometry.to_list()])
    B = [np.array(geom.coords) for geom in gdfB.geometry.to_list()]
    B_ix = tuple(
        itertools.chain.from_iterable(
            [itertools.repeat(i, x) for i, x in enumerate(list(map(len, B)))]
        )
    )
    B = np.concatenate(B)
    ckd_tree = cKDTree(B)
    dist, idx = ckd_tree.query(A, k=1)
    idx = itemgetter(*idx)(B_ix)
    gdf = pd.concat(
        [
            gdfA,
            gdfB.loc[idx, gdfB_cols].reset_index(drop=True),
            pd.Series(dist, name=&#34;dist&#34;),
        ],
        axis=1,
    )
    return gdf</code></pre>
</details>
</dd>
<dt id="pysewer.helper.get_closest_edge"><code class="name flex">
<span>def <span class="ident">get_closest_edge</span></span>(<span>G: networkx.classes.graph.Graph, point: shapely.geometry.point.Point) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the closest edge to a given point in a networkx graph.</p>
<h2 id="parameters">Parameters:</h2>
<p>G : networkx.Graph
The graph to search for the closest edge.
point : shapely.geometry.Point
The point to search for the closest edge.</p>
<h2 id="returns">Returns:</h2>
<p>closest_edge : tuple
A tuple representing the closest edge to the given point.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_closest_edge(G: nx.Graph, point: shapely.geometry.Point) -&gt; tuple:
    &#34;&#34;&#34;
    Returns the closest edge to a given point in a networkx graph.

    Parameters:
    -----------
    G : networkx.Graph
        The graph to search for the closest edge.
    point : shapely.geometry.Point
        The point to search for the closest edge.

    Returns:
    --------
    closest_edge : tuple
        A tuple representing the closest edge to the given point.
    &#34;&#34;&#34;
    edge_gdf = get_edge_gdf(G)
    edge_gdf[&#34;closest_edge&#34;] = edge_gdf.geometry.tolist()
    cc = ckdnearest(
        gpd.GeoDataFrame(geometry=[point]), edge_gdf, [&#34;closest_edge&#34;]
    ).iloc[0, 1]
    # Validate the returned type
    if not isinstance(cc, tuple):
        raise ValueError(
            &#34;Expected a tuple representing an edge but got a different type.&#34;
        )

    return cc</code></pre>
</details>
</dd>
<dt id="pysewer.helper.get_closest_edge_multiple"><code class="name flex">
<span>def <span class="ident">get_closest_edge_multiple</span></span>(<span>G: networkx.classes.graph.Graph, list_of_points: list) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of the closest edges in a networkx graph to a list of points.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>networkx.Graph</code></dt>
<dd>A networkx graph object.</dd>
<dt><strong><code>list_of_points</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of shapely Point objects.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of shapely LineString objects representing the closest edges to the input points.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_closest_edge_multiple(G: nx.Graph, list_of_points: list) -&gt; list:
    &#34;&#34;&#34;
    Returns a list of the closest edges in a networkx graph to a list of points.

    Parameters
    ----------
    G : networkx.Graph
        A networkx graph object.
    list_of_points : list
        A list of shapely Point objects.

    Returns
    -------
    list
        A list of shapely LineString objects representing the closest edges to the input points.
    &#34;&#34;&#34;
    edge_gdf = get_edge_gdf(G)
    edge_gdf[&#34;closest_edge&#34;] = edge_gdf.geometry.tolist()
    cc = ckdnearest(
        gpd.GeoDataFrame(geometry=list_of_points), edge_gdf, [&#34;closest_edge&#34;]
    )[&#34;closest_edge&#34;].to_list()
    return cc</code></pre>
</details>
</dd>
<dt id="pysewer.helper.get_edge_gdf"><code class="name flex">
<span>def <span class="ident">get_edge_gdf</span></span>(<span>G: networkx.classes.graph.Graph, field: str = None, value: <built-in function any> = None, detailed: bool = False) ‑> geopandas.geodataframe.GeoDataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a GeoDataFrame of edges in a networkx graph that match a given field and value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>networkx.Graph</code></dt>
<dd>The graph to extract edges from.</dd>
<dt><strong><code>field</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The edge attribute to filter on.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>any</code>, optional</dt>
<dd>The value to filter the edge attribute on.</dd>
<dt><strong><code>detailed</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, returns a detailed GeoDataFrame with all edge attributes. If False, returns a simplified GeoDataFrame with only the edge geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gpd.GeoDataFrame</code></dt>
<dd>A GeoDataFrame of edges that match the given field and value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_edge_gdf(
    G: nx.Graph, field: str = None, value: any = None, detailed: bool = False
) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Returns a GeoDataFrame of edges in a networkx graph that match a given field and value.

    Parameters
    ----------
    G : networkx.Graph
        The graph to extract edges from.
    field : str, optional
        The edge attribute to filter on.
    value : any, optional
        The value to filter the edge attribute on.
    detailed : bool, optional
        If True, returns a detailed GeoDataFrame with all edge attributes. If False, returns a simplified GeoDataFrame with only the edge geometry.

    Returns
    -------
    gpd.GeoDataFrame
        A GeoDataFrame of edges that match the given field and value.
    &#34;&#34;&#34;
    edges = get_edge_keys(G, field=field, value=value)
    # If no matching edges are found, return an empty GeoDataFrame
    if not edges:
        return gpd.GeoDataFrame()

    data = [G[edge[0]][edge[1]] for edge in edges]

    if detailed:
        return gpd.GeoDataFrame(data)
    else:
        return gpd.GeoDataFrame(geometry=[LineString(e) for e in edges])</code></pre>
</details>
</dd>
<dt id="pysewer.helper.get_edge_keys"><code class="name flex">
<span>def <span class="ident">get_edge_keys</span></span>(<span>G, field=None, value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of edge keys (tuples of nodes) for the given graph <code>G</code> that have an edge attribute <code>field</code> with value <code>value</code>.</p>
<h2 id="parameters">Parameters:</h2>
<p>G : networkx.Graph
The graph to search for edges.
field : str, optional
The name of the edge attribute to filter on.
value : any, optional
The value of the edge attribute to filter on.</p>
<h2 id="returns">Returns:</h2>
<p>list of tuples
A list of edge keys (tuples of nodes) that have an edge attribute <code>field</code> with value <code>value</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_edge_keys(G, field=None, value=None):
    &#34;&#34;&#34;
    Returns a list of edge keys (tuples of nodes) for the given graph `G` that have an edge attribute `field` with value `value`.

    Parameters:
    -----------
    G : networkx.Graph
        The graph to search for edges.
    field : str, optional
        The name of the edge attribute to filter on.
    value : any, optional
        The value of the edge attribute to filter on.

    Returns:
    --------
    list of tuples
        A list of edge keys (tuples of nodes) that have an edge attribute `field` with value `value`.
    &#34;&#34;&#34;
    return [(u, v) for u, v, e in G.edges(data=field, default=None) if e == value]</code></pre>
</details>
</dd>
<dt id="pysewer.helper.get_mean_slope"><code class="name flex">
<span>def <span class="ident">get_mean_slope</span></span>(<span>G: networkx.classes.multidigraph.MultiDiGraph, upstream: int, downstream: int, us_td: float, ds_td: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the mean slope of a path between two nodes in a graph.</p>
<h2 id="parameters">Parameters:</h2>
<p>G : networkx.MultiDiGraph
A directed graph object.
upstream : int
The upstream node ID.
downstream : int
The downstream node ID.
us_td : float
The upstream node topographic elevation.
ds_td : float
The downstream node topographic elevation.</p>
<h2 id="returns">Returns:</h2>
<p>float
The mean slope of the path between the upstream and downstream nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mean_slope(
    G: nx.MultiDiGraph, upstream: int, downstream: int, us_td: float, ds_td: float
) -&gt; float:
    &#34;&#34;&#34;
    Calculates the mean slope of a path between two nodes in a graph.

    Parameters:
    -----------
    G : networkx.MultiDiGraph
        A directed graph object.
    upstream : int
        The upstream node ID.
    downstream : int
        The downstream node ID.
    us_td : float
        The upstream node topographic elevation.
    ds_td : float
        The downstream node topographic elevation.

    Returns:
    --------
    float
        The mean slope of the path between the upstream and downstream nodes.
    &#34;&#34;&#34;
    gdf = get_path_gdf(G, upstream, downstream)
    length = gdf[&#34;geometry&#34;].length.sum()
    return (ds_td - us_td) / length</code></pre>
</details>
</dd>
<dt id="pysewer.helper.get_node_gdf"><code class="name flex">
<span>def <span class="ident">get_node_gdf</span></span>(<span>G: networkx.classes.graph.Graph, field=None, value=None) ‑> geopandas.geodataframe.GeoDataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a GeoDataFrame of nodes in the graph that match the specified field and value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>nx.Graph</code></dt>
<dd>The input graph.</dd>
<dt><strong><code>field</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The node attribute to filter on.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The value to filter on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>gdf</code></strong> :&ensp;<code>gpd.GeoDataFrame</code></dt>
<dd>A GeoDataFrame of nodes that match the specified field and value.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If no geometry column is found in the GeoDataFrame.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This function filters the nodes in the input graph based on the specified field and value, and returns a GeoDataFrame
containing the filtered nodes and their attributes. The GeoDataFrame is created using the coordinates of the filtered
nodes and their attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_gdf(G: nx.Graph, field=None, value=None) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Returns a GeoDataFrame of nodes in the graph that match the specified field and value.

    Parameters
    ----------
    G : nx.Graph
        The input graph.
    field : str, optional
        The node attribute to filter on.
    value : str, optional
        The value to filter on.

    Returns
    -------
    gdf : gpd.GeoDataFrame
        A GeoDataFrame of nodes that match the specified field and value.

    Raises
    ------
    ValueError
        If no geometry column is found in the GeoDataFrame.

    Notes
    -----
    This function filters the nodes in the input graph based on the specified field and value, and returns a GeoDataFrame
    containing the filtered nodes and their attributes. The GeoDataFrame is created using the coordinates of the filtered
    nodes and their attributes.

    &#34;&#34;&#34;
    coord_tuples = get_node_keys(G, field=field, value=value)
    try:
        x, y = zip(*coord_tuples)
        data = [G.nodes(data=True)[n] for n in coord_tuples]
        gdf = gpd.GeoDataFrame(data, geometry=gpd.points_from_xy(x, y))
        if &#34;geometry&#34; not in gdf.columns:
            raise ValueError(&#34;No geometry column found in the GeoDataFrame.&#34;)

        return gdf.set_geometry(&#34;geometry&#34;)

    except:
        return gpd.GeoDataFrame()</code></pre>
</details>
</dd>
<dt id="pysewer.helper.get_node_keys"><code class="name flex">
<span>def <span class="ident">get_node_keys</span></span>(<span>G: networkx.classes.graph.Graph, field: str = None, value: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of keys for nodes in the graph <code>G</code> that have a specified <code>field</code> with a specified <code>value</code>.</p>
<h2 id="parameters">Parameters:</h2>
<p>G : networkx.Graph
The graph to search for nodes.
field : str, optional
The field to search for in the node data dictionary. If None, all nodes are returned.
value : str
The value to search for in the specified <code>field</code>. If None, all nodes with the specified <code>field</code> are returned.</p>
<h2 id="returns">Returns:</h2>
<p>list
A list of keys for nodes in the graph <code>G</code> that have a specified <code>field</code> with a specified <code>value</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_keys(G: nx.Graph, field: str = None, value: str = None):
    &#34;&#34;&#34;
    Returns a list of keys for nodes in the graph `G` that have a specified `field` with a specified `value`.

    Parameters:
    -----------
    G : networkx.Graph
        The graph to search for nodes.
    field : str, optional
        The field to search for in the node data dictionary. If None, all nodes are returned.
    value : str
        The value to search for in the specified `field`. If None, all nodes with the specified `field` are returned.

    Returns:
    --------
    list
        A list of keys for nodes in the graph `G` that have a specified `field` with a specified `value`.
    &#34;&#34;&#34;
    return [x for x, y in G.nodes(data=field, default=None) if y == value]</code></pre>
</details>
</dd>
<dt id="pysewer.helper.get_path_distance"><code class="name flex">
<span>def <span class="ident">get_path_distance</span></span>(<span>detailed_path: List[tuple]) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the total distance of a path given a list of detailed path coordinates.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>detailed_path</code></strong> :&ensp;<code>List[tuple]</code></dt>
<dd>A list of tuples representing the detailed path coordinates.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The total distance of the path.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; get_path_distance([(0, 0), (3, 4), (7, 1)])
9.848857801796104
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_path_distance(detailed_path: List[tuple]) -&gt; float:
    &#34;&#34;&#34;
    Calculates the total distance of a path given a list of detailed path coordinates.

    Parameters
    ----------
    detailed_path : List[tuple]
        A list of tuples representing the detailed path coordinates.

    Returns
    -------
    float
        The total distance of the path.

    Examples
    --------
    &gt;&gt;&gt; get_path_distance([(0, 0), (3, 4), (7, 1)])
    9.848857801796104
    &#34;&#34;&#34;
    edgesinpath = zip(detailed_path[0:], detailed_path[1:])
    path_dist = 0
    for e in edgesinpath:
        path_dist += distance.euclidean(e[0], e[1])
    return path_dist</code></pre>
</details>
</dd>
<dt id="pysewer.helper.get_path_gdf"><code class="name flex">
<span>def <span class="ident">get_path_gdf</span></span>(<span>G, upstream, downstream)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a GeoDataFrame containing the geometry of the shortest path between two nodes in a graph.</p>
<h2 id="parameters">Parameters:</h2>
<p>G : networkx.Graph
The graph to find the shortest path in.
upstream : int
The starting node of the path.
downstream : int
The ending node of the path.</p>
<h2 id="returns">Returns:</h2>
<p>gpd.GeoDataFrame
A GeoDataFrame containing the geometry of the shortest path between the upstream and downstream nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_path_gdf(G, upstream, downstream):
    &#34;&#34;&#34;
    Returns a GeoDataFrame containing the geometry of the shortest path between two nodes in a graph.

    Parameters:
    -----------
    G : networkx.Graph
        The graph to find the shortest path in.
    upstream : int
        The starting node of the path.
    downstream : int
        The ending node of the path.

    Returns:
    --------
    gpd.GeoDataFrame
        A GeoDataFrame containing the geometry of the shortest path between the upstream and downstream nodes.
    &#34;&#34;&#34;
    path = nx.dijkstra_path(G, upstream, downstream)
    edges = list(zip(path[0:], path[1:]))
    return gpd.GeoDataFrame(geometry=[G[e[0]][e[1]][&#34;geometry&#34;] for e in edges])</code></pre>
</details>
</dd>
<dt id="pysewer.helper.get_upstream_nodes"><code class="name flex">
<span>def <span class="ident">get_upstream_nodes</span></span>(<span>G: networkx.classes.digraph.DiGraph, start_node, field: str, value: str) ‑> List</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of all upstream nodes in a directed graph <code>G</code> that have a node attribute <code>field</code> with value <code>value</code>,
starting from <code>start_node</code> and traversing the graph in reverse order using a breadth-first search algorithm.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>networkx.DiGraph</code></dt>
<dd>The directed graph to traverse.</dd>
<dt><strong><code>start_node</code></strong> :&ensp;<code>hashable</code></dt>
<dd>The node to start the traversal from.</dd>
<dt><strong><code>field</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the node attribute to filter by.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>Any</code></dt>
<dd>The value of the node attribute to filter by.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code></dt>
<dd>A list of all upstream nodes in <code>G</code> that have a node attribute <code>field</code> with value <code>value</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_upstream_nodes(G: nx.DiGraph, start_node, field: str, value: str) -&gt; List:
    &#34;&#34;&#34;
    Returns a list of all upstream nodes in a directed graph `G` that have a node attribute `field` with value `value`,
    starting from `start_node` and traversing the graph in reverse order using a breadth-first search algorithm.

    Parameters
    ----------
    G : networkx.DiGraph
        The directed graph to traverse.
    start_node : hashable
        The node to start the traversal from.
    field : str
        The name of the node attribute to filter by.
    value : Any
        The value of the node attribute to filter by.

    Returns
    -------
    List
        A list of all upstream nodes in `G` that have a node attribute `field` with value `value`.
    &#34;&#34;&#34;
    return [
        n
        for n in nx.traversal.bfs_tree(G, start_node, reverse=True)
        if G.nodes(data=field, default=None)[n] == value
    ]</code></pre>
</details>
</dd>
<dt id="pysewer.helper.remove_third_dimension"><code class="name flex">
<span>def <span class="ident">remove_third_dimension</span></span>(<span>geom)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_third_dimension(geom):
    if geom.is_empty:
        return geom

    if isinstance(geom, Polygon):
        exterior = geom.exterior
        new_exterior = remove_third_dimension(exterior)

        interiors = geom.interiors
        new_interiors = []
        for int in interiors:
            new_interiors.append(remove_third_dimension(int))

        return Polygon(new_exterior, new_interiors)

    elif isinstance(geom, LinearRing):
        return LinearRing([xy[0:2] for xy in list(geom.coords)])

    elif isinstance(geom, LineString):
        return LineString([xy[0:2] for xy in list(geom.coords)])

    elif isinstance(geom, Point):
        return Point([xy[0:2] for xy in list(geom.coords)])

    elif isinstance(geom, MultiPoint):
        points = list(geom.geoms)
        new_points = []
        for point in points:
            new_points.append(remove_third_dimension(point))

        return MultiPoint(new_points)

    elif isinstance(geom, MultiLineString):
        lines = list(geom.geoms)
        new_lines = []
        for line in lines:
            new_lines.append(remove_third_dimension(line))

        return MultiLineString(new_lines)

    elif isinstance(geom, MultiPolygon):
        pols = list(geom.geoms)

        new_pols = []
        for pol in pols:
            new_pols.append(remove_third_dimension(pol))

        return MultiPolygon(new_pols)

    elif isinstance(geom, GeometryCollection):
        geoms = list(geom.geoms)

        new_geoms = []
        for geom in geoms:
            new_geoms.append(remove_third_dimension(geom))

        return GeometryCollection(new_geoms)

    else:
        raise RuntimeError(
            &#34;Currently this type of geometry is not supported: {}&#34;.format(type(geom))
        )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pysewer" href="index.html">pysewer</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pysewer.helper.ckdnearest" href="#pysewer.helper.ckdnearest">ckdnearest</a></code></li>
<li><code><a title="pysewer.helper.get_closest_edge" href="#pysewer.helper.get_closest_edge">get_closest_edge</a></code></li>
<li><code><a title="pysewer.helper.get_closest_edge_multiple" href="#pysewer.helper.get_closest_edge_multiple">get_closest_edge_multiple</a></code></li>
<li><code><a title="pysewer.helper.get_edge_gdf" href="#pysewer.helper.get_edge_gdf">get_edge_gdf</a></code></li>
<li><code><a title="pysewer.helper.get_edge_keys" href="#pysewer.helper.get_edge_keys">get_edge_keys</a></code></li>
<li><code><a title="pysewer.helper.get_mean_slope" href="#pysewer.helper.get_mean_slope">get_mean_slope</a></code></li>
<li><code><a title="pysewer.helper.get_node_gdf" href="#pysewer.helper.get_node_gdf">get_node_gdf</a></code></li>
<li><code><a title="pysewer.helper.get_node_keys" href="#pysewer.helper.get_node_keys">get_node_keys</a></code></li>
<li><code><a title="pysewer.helper.get_path_distance" href="#pysewer.helper.get_path_distance">get_path_distance</a></code></li>
<li><code><a title="pysewer.helper.get_path_gdf" href="#pysewer.helper.get_path_gdf">get_path_gdf</a></code></li>
<li><code><a title="pysewer.helper.get_upstream_nodes" href="#pysewer.helper.get_upstream_nodes">get_upstream_nodes</a></code></li>
<li><code><a title="pysewer.helper.remove_third_dimension" href="#pysewer.helper.remove_third_dimension">remove_third_dimension</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>